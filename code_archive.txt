/*
archive of functions and code from project's misty past...
oh, those were the days...
*/

/// Recursively collects file system entries from directory and all subdirectories
///
/// # Purpose
/// Traverses a directory tree starting from the specified root directory,
/// collecting all files and subdirectories for searching operations.
///
/// # Critical Implementation Note
/// This function MUST receive the actual directory to search, not assume
/// any particular directory. The caller is responsible for providing the
/// correct starting directory based on the application's navigation state.
///
/// # Arguments
/// * `start_directory` - The root directory from which to start collecting.
///                       This should be the user's current navigation location,
///                       NOT the process working directory.
///
/// # Common Mistake
/// DO NOT use std::env::current_dir() here or in calling code.
/// The process working directory is NOT the same as the file manager's
/// current navigation directory.
fn collect_entries_recursive(
    &self,
    start_directory: &Path,  // Must be the actual navigation directory
) -> Result<Vec<FileSystemEntry>> {
    let mut all_entries = Vec::new();
    let mut directories_to_process = vec![start_directory.to_path_buf()];

    while let Some(current_dir) = directories_to_process.pop() {
        // Try to read the current directory, skip if we can't
        let dir_entries = match fs::read_dir(&current_dir) {
            Ok(entries) => entries,
            Err(_) => continue, // Skip directories we can't read
        };

        for entry_result in dir_entries {
            // Skip entries we can't read
            let entry = match entry_result {
                Ok(e) => e,
                Err(_) => continue,
            };

            // Get metadata, skip if we can't read it
            let metadata = match entry.metadata() {
                Ok(m) => m,
                Err(_) => continue,
            };

            // Get the file name as a string, skip if invalid
            let file_name = match entry.file_name().into_string() {
                Ok(name) => name,
                Err(_) => continue,
            };

            let path = entry.path();

            // Add to entries list
            all_entries.push(FileSystemEntry {
                file_system_item_name: file_name,
                file_system_item_path: path.clone(),
                file_system_item_size_in_bytes: metadata.len(),
                file_system_item_last_modified_time: metadata.modified()
                    .unwrap_or(SystemTime::UNIX_EPOCH),
                is_directory: metadata.is_dir(),
            });

            // If it's a directory, add it to the processing queue
            if metadata.is_dir() {
                directories_to_process.push(path);
            }
        }
    }

    Ok(all_entries)
}


    // Pass the correct is_grep flag to display function
    display_extended_search_results(&search_results).map_err(|e| {
        eprintln!("Failed to display search results: {}", e);
        FileFantasticError::Io(e)
    })?;

    // Wait for user to select from results or press enter to continue
    print!("\nEnter number to select or press Enter to continue: ");
    io::stdout().flush().map_err(|e| {
        eprintln!("Failed to flush stdout: {}", e);
        FileFantasticError::Io(e)
    })?;

    let mut selection = String::new();
    io::stdin().read_line(&mut selection).map_err(|e| {
        eprintln!("Failed to read input: {}", e);
        FileFantasticError::Io(e)
    })?;

/// simple, works, no pagination
/// Displays search results with appropriate formatting based on search type
///
/// # Purpose
/// Presents search results to the user in a readable tabular format,
/// automatically detecting the search type from the result enum and displaying
/// the appropriate format for each type.
///
/// # Arguments
/// * `results` - Slice of UnifiedSearchResult items to display
///               The enum variant determines the display format
///
/// # Returns
/// * `io::Result<()>` - Ok(()) on successful display, or an IO error if terminal
///                       output operations fail
///
/// # Display Formats
///
/// ## Fuzzy Name Search Format:
/// Shows the Levenshtein distance to help users understand match quality
/// ```text
/// Search Results (Fuzzy Match)
/// #     Name                                     Distance
/// -------------------------------------------------------
/// 1     example.txt                              1
/// 2     example2.doc                             2
/// ```
///
/// ## Grep Content Search Format:
/// Shows the line number and content for each match
/// ```text
/// Search Results (Content Match)
/// #     File                                     Line    Content
/// --------------------------------------------------------------
/// 1     src/main.rs                              42      // TODO: implement
/// 2     src/lib.rs                               15      // TODO: document
/// ```
///
/// # Implementation Details
/// - Clears the terminal screen before displaying results for clean presentation
/// - Truncates long filenames to maintain table alignment (max 38 characters)
/// - Automatically detects search type from enum variant
/// - Shows "No matches found" message for empty result sets
///
/// # User Interface Flow
/// After displaying results, the user can:
/// - Enter a number to select and navigate to that file
/// - Press Enter to continue without selection
///
/// # Error Handling
/// - Returns IO errors from terminal output operations
/// - Handles empty result sets gracefully with informative message
pub fn display_extended_search_results(
    results: &[UnifiedSearchResult],
) -> io::Result<()> {  // Note: removed is_grep parameter - not needed with enum

    // Handle empty results with user-friendly message
    if results.is_empty() {
        println!("No matches found");
        return Ok(());
    }

    // Clear screen for clean display
    print!("\x1B[2J\x1B[1;1H");

    // Determine search type from first result and display accordingly
    match &results[0] {
        UnifiedSearchResult::Grep(_) => {
            // Display header for grep results
            println!("\nContent Search Results (try: -g -r -c)"); // -fg --fuzzygrep
            println!("{:<5} {:<30} {:<7} {}", "#", "File", "Line", "Content");
            println!("{}", "-".repeat(80));

            // Display each grep result
            for result in results {
                if let UnifiedSearchResult::Grep(grep_result) = result {
                    // Truncate filename if too long
                    let display_name = if grep_result.file_name.len() > 28 {
                        format!("{}...", &grep_result.file_name[..25])
                    } else {
                        grep_result.file_name.clone()
                    };

                    // Truncate content if too long
                    let display_content = if grep_result.line_content.len() > 35 {
                        format!("{}...", &grep_result.line_content[..32])
                    } else {
                        grep_result.line_content.clone()
                    };

                    println!(
                        "{:<5} {:<30} {:<7} {}",
                        grep_result.display_index,
                        display_name,
                        grep_result.line_number,
                        display_content
                    );
                }
            }
        }

        UnifiedSearchResult::Fuzzy(_) => {
            // Display header for fuzzy search results
            println!("\nFuzzy Name Search Results (try: --grep --recursive --case-sensitive)");
            println!("{:<5} {:<40} {:<10}", "#", "Name", "Distance");
            println!("{}", "-".repeat(55));

            // Display each fuzzy result
            for result in results {
                if let UnifiedSearchResult::Fuzzy(fuzzy_result) = result {
                    // Truncate filename if too long
                    let display_name = if fuzzy_result.item_name.len() > 38 {
                        format!("{}...", &fuzzy_result.item_name[..35])
                    } else {
                        fuzzy_result.item_name.clone()
                    };

                    println!(
                        "{:<5} {:<40} {:<10}",
                        fuzzy_result.display_index,
                        display_name,
                        fuzzy_result.distance
                    );
                }
            }
        }
    }

    Ok(())
}


// /// Creates archive directory if it doesn't exist
// ///
// /// # Purpose
// /// Ensures that an "archive" subdirectory exists in the specified parent directory,
// /// creating it if necessary. This directory is used to store copies of files
// /// when avoiding overwrites.
// ///
// /// # Arguments
// /// * `parent_directory` - The directory where the archive folder should exist
// ///
// /// # Returns
// /// * `Result<PathBuf>` - Absolute path to the archive directory, or error
// ///
// /// # Error Conditions
// /// - IO errors when creating the directory
// /// - Permission denied when writing to parent directory
// /// - Invalid parent directory path
// ///
// /// # Archive Directory Structure
// /// ```text
// /// parent_directory/
// /// ├── existing_files...
// /// └── archive/          <- Created by this function
// ///     ├── file1_timestamp.ext
// ///     └── file2_timestamp.ext
// /// ```
// ///
// /// # Example
// /// ```rust
// /// let current_dir = PathBuf::from("/home/user/documents");
// /// match ensure_archive_directory_exists(&current_dir) {
// ///     Ok(archive_path) => {
// ///         // archive_path is "/home/user/documents/archive"
// ///         println!("Archive directory ready: {}", archive_path.display());
// ///     },
// ///     Err(e) => eprintln!("Failed to create archive directory: {}", e),
// /// }
// /// ```
// fn ensure_archive_directory_exists(parent_directory: &PathBuf) -> Result<PathBuf> {
//     let archive_directory_path = parent_directory.join("archive");

//     // Check if archive directory already exists
//     if !archive_directory_path.exists() {
//         // Create the archive directory
//         fs::create_dir(&archive_directory_path).map_err(|e| {
//             match e.kind() {
//                 io::ErrorKind::PermissionDenied => {
//                     FileFantasticError::PermissionDenied(archive_directory_path.clone())
//                 },
//                 _ => FileFantasticError::Io(e)
//             }
//         })?;

//         println!("Created archive directory: {}", archive_directory_path.display());
//     }

//     // Verify it's actually a directory
//     if !archive_directory_path.is_dir() {
//         return Err(FileFantasticError::InvalidName(
//             format!("Archive path exists but is not a directory: {}",
//                    archive_directory_path.display())
//         ));
//     }

//     Ok(archive_directory_path)
// }


// /// Opens a file in a tmux split pane
// ///
// /// # Arguments
// /// * `editor` - The editor command to use
// /// * `file_path` - Path to the file to open
// /// * `split_type` - Either "-v" for vertical or "-h" for horizontal split
// ///
// /// # Returns
// /// * `Result<()>` - Success or error
// ///
// /// # Prerequisites
// /// - tmux must be installed and available
// /// - Must be running inside a tmux session
// ///
// /// # Behavior
// /// Creates a new tmux pane and opens the editor in it
// /// The pane closes automatically when the editor exits
// fn open_in_tmux_split(editor: &str, file_path: &PathBuf, split_type: &str) -> Result<()> {
//     // Check if the specified editor is available
//     if !is_command_available(editor) {
//         return Err(FileFantasticError::EditorLaunchFailed(format!(
//             "Editor '{}' is not available on this system",
//             editor
//         )));
//     }

//     // Build the command to run in the new split
//     let editor_command = format!("{} {}", editor, file_path.to_string_lossy());

//     // Create the tmux split with the editor
//     let output = std::process::Command::new("tmux")
//         .args([
//             "split-window",
//             split_type, // "-v" for vertical, "-h" for horizontal
//             &editor_command,
//         ])
//         .output()
//         .map_err(|e| {
//             eprintln!("Failed to create tmux split: {}", e);
//             FileFantasticError::Io(e)
//         })?;

//     if output.status.success() {
//         println!(
//             "Opened {} in tmux {} split",
//             editor,
//             if split_type == "-v" {
//                 "vertical"
//             } else {
//                 "horizontal"
//             }
//         );
//         Ok(())
//     } else {
//         Err(FileFantasticError::EditorLaunchFailed(format!(
//             "Failed to create tmux split: {}",
//             String::from_utf8_lossy(&output.stderr)
//         )))
//     }
// }



/// Parses special flags from user input for headless mode, tmux splits, and CSV analysis
///
/// # Arguments
/// * `input` - The user input string
///
/// # Returns
/// * `Option<(String, String)>` - Some((editor, flag)) if a special flag is found, None otherwise
///
/// # Supported Flags
/// * `-h` or `--headless` - Open in current terminal
/// * `-vsplit` or `--vertical-split-tmux` - Open in vertical tmux split
/// * `-hsplit` or `--horizontal-split-tmux` - Open in horizontal tmux split
/// * `-rc` or `--rows-and-columns` - Analyze CSV file before opening (CSV files only)
///
/// # Examples
/// * "vim -h" -> Some(("vim", "-h"))
/// * "nano -rc" -> Some(("nano", "-rc"))
/// * "code -h -rc" -> Some(("code", "-h -rc")) // Combined flags preserved
fn parse_special_flags(input: &str) -> Option<(String, String)> {
    let flags = [
        "-h",
        "--headless",
        "-vsplit",
        "--vertical-split-tmux",
        "-hsplit",
        "--horizontal-split-tmux",
        "-rc",
        "--rows-and-columns",
    ];

    // Check if input contains any special flags
    let mut found_flags = Vec::new();
    let mut editor_parts = Vec::new();

    let parts: Vec<&str> = input.split_whitespace().collect();

    for part in &parts {
        if flags.contains(&part.as_ref()) {
            found_flags.push(part.to_string());
        } else {
            editor_parts.push(part.to_string());
        }
    }

    if !found_flags.is_empty() {
        let editor = editor_parts.join(" ");
        let flags_str = found_flags.join(" ");
        Some((editor, flags_str))
    } else {
        None
    }
}

        // // Now handle the other flags with the appropriate file
        // // Extract the primary action flag (for headless/tmux)
        // let primary_flag = if flags.contains("-h") || flags.contains("--headless") {
        //     "--headless"
        // } else if flags.contains("-vsplit") || flags.contains("--vertical-split-tmux") {
        //     "-vsplit"
        // } else if flags.contains("-hsplit") || flags.contains("--horizontal-split-tmux") {
        //     "-hsplit"
        // } else if flags.contains("-rc") || flags.contains("--rows-and-columns") {
        //     // If only -rc flag, open normally (no special terminal mode)
        //     ""
        // } else {
        //     ""
        // };



    /// Interactive interface to add a file to the file stack
    ///
    /// # Purpose
    /// Provides a simple interactive interface for adding files to the file stack.
    /// Shows the current directory listing and prompts user to select a file by number.
    /// Works with the current page view only, utilizing existing navigation state.
    ///
    /// # Arguments
    /// * `nav_state` - Current navigation state with lookup table for numbered selection
    /// * `current_directory_entries` - Current directory entries to display for selection (current page only)
    /// * `current_directory_path` - Current directory path for display context
    ///
    /// # Returns
    /// * `Result<()>` - Success or error with context
    ///
    /// # User Interface Workflow
    ///
    /// ## Step 1: Display Current View
    /// - Show current directory contents with numbered items (same as main navigation)
    /// - This respects current filter and pagination state
    ///
    /// ## Step 2: Selection Prompt
    /// - User selects item by number (same interface as navigation)
    /// - Can cancel with 'b' for back
    ///
    /// ## Step 3: Validation
    /// - Verify selected item exists in lookup table
    /// - Ensure selected item is a file (not a directory)
    ///
    /// ## Step 4: Add to Stack
    /// - Add file path to the file stack
    /// - Display confirmation with updated stack count
    ///
    /// # Example Interaction
    /// ```text
    /// Current Directory: /home/user/documents
    ///
    /// Num  Name                    Size     Modified
    /// ------------------------------------------------
    ///  1)  folder1/               -        14:30
    ///  2)  document.txt           1.2 KB   15:45
    ///  3)  image.png              500 KB   16:20
    ///
    /// === Add File to Stack ===
    /// Select file to add to stack
    /// Enter file number (or 'b' to back/cancel): 2
    ///
    /// ✓ Added 'document.txt' to file stack. Total files: 1
    /// ```
    ///
    /// # Error Handling
    /// - Validates numbered selections against navigation lookup table
    /// - Ensures selected items are files, not directories
    /// - Provides clear error messages for invalid selections
    /// - Handles cancellation gracefully
    /// - Manages IO errors during user interaction
    pub fn interactive_add_file_tostack(
        &mut self,
        nav_state: &NavigationState,
        current_directory_entries: &[FileSystemEntry],
        current_directory_path: &PathBuf,
    ) -> Result<()> {
        // WORKFLOW STEP 1: Display current directory contents
        // This shows the current page with existing filters and numbering
        display_directory_contents(
            current_directory_entries,
            current_directory_path,
            None, // Pagination info handled by main navigation
            nav_state.current_filter,
            nav_state,
        )
        .map_err(|e| FileFantasticError::Io(e))?;

        // WORKFLOW STEP 2: Prompt for file selection
        println!("\n=== Add File to Stack ===");
        println!("Select file to add to stack");
        print!("Enter file number (or 'b' to back/cancel): ");
        io::stdout()
            .flush()
            .map_err(|e| FileFantasticError::Io(e))?;

        // Read user input
        let mut input = String::new();
        io::stdin()
            .read_line(&mut input)
            .map_err(|e| FileFantasticError::Io(e))?;
        let input = input.trim();

        // Handle cancellation request
        if input.eq_ignore_ascii_case("b") {
            println!("Back/Cancelled.");
            return Ok(());
        }

        // WORKFLOW STEP 3: Validate and process the user's selection
        if let Ok(number) = input.parse::<usize>() {
            // Use navigation state's lookup to find the selected item
            if let Some(item_info) = nav_state.lookup_item(number) {
                // Check if selected item is a file (not a directory)
                if item_info.item_type == FileSystemItemType::Directory {
                    // User selected a directory - show error and return
                    let item_name = item_info
                        .item_path
                        .file_name()
                        .unwrap_or_default()
                        .to_string_lossy();
                    eprintln!(
                        "\n✗ Error: '{}' is a directory. Please select a file.",
                        item_name
                    );
                } else {
                    // WORKFLOW STEP 4: It's a file - add to stack

                    // Extract file name for display
                    let file_name = item_info
                        .item_path
                        .file_name()
                        .unwrap_or_default()
                        .to_string_lossy();

                    // Add the file to the stack
                    match self.add_file_to_stack(item_info.item_path.clone()) {
                        Ok(()) => {
                            // Success - show confirmation with stack count
                            println!(
                                "\n✓ Added '{}' to file stack. Total files: {}",
                                file_name,
                                self.file_path_stack.len()
                            );
                        }
                        Err(e) => {
                            // Failed to add to stack - show error
                            eprintln!("\n✗ Failed to add file to stack: {}", e);
                        }
                    }
                }
            } else {
                // Invalid item number - not in lookup table
                println!("Error: Invalid item number {}. Please try again.", number);
            }
        } else {
            // Input was not a valid number
            println!("Error: Please enter a valid number or 'b' to cancel.");
        }

        // Wait for user acknowledgment before returning to main interface
        println!("\nPress Enter to continue...");
        let _ = io::stdin().read_line(&mut String::new());

        Ok(())
    }
